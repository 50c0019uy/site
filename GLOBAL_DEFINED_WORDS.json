{
  "適格": {
    "link": "/implementation-compliance.md#dfn-well-formed",
    "yomi": "てきかく",
    "desc": "プログラムが文法規則・診断対象の意味規則・単一定義規則を満たすこと"
  },
  "不適格": {
    "link": "/implementation-compliance.md#dfn-ill-formed",
    "yomi": "ふてきかく",
    "desc": "プログラムが適格でないこと。コンパイルエラーなどになる"
  },
  "未定義の動作": {
    "link": "/implementation-compliance.md#dfn-undefined-behavior",
    "yomi": "みていぎのどうさ",
    "desc": "処理系は予期せぬ動作をする可能性がある。要するに動作保証対象外。undefined behavior (UB)。"
  },
  "未定義動作": { "redirect": "未定義の動作", "yomi": "みていぎどうさ" },
  "動作は未定義": { "redirect": "未定義の動作", "yomi": "どうさはみていぎ" },
  "未定義": { "redirect": "未定義の動作", "yomi": "みていぎ" },
  "未定義アドレス": {
    "yomi": "みていぎあどれす",
    "desc": "通常は未定義動作となるポインタの加減算が atomic 操作として行われた場合の結果を指す規格中の表記「undefined address」を指す。その意味付けは不明確なので LWG issue 3906. Undefined address is undefined が提起されている。atomic操作は未定義動作を含まないことを意図して設計されているため未定義アドレスは未定義動作ではないと考えられる",
    "link": "https://cplusplus.github.io/LWG/issue3906"
  },
  "未規定の動作": {
    "link": "/implementation-compliance.md#dfn-unspecified-behavior",
    "yomi": "みきていのどうさ",
    "desc": "事前の断りなく処理系によって異なる動作をする"
  },
  "未規定動作": { "redirect": "未規定の動作", "yomi": "みきていどうさ" },
  "未規定": { "redirect": "未規定の動作", "yomi": "みきてい" },
  "エラー性の動作": {
    "link": "/implementation-compliance.md#dfn-erroneous-behavior",
    "yomi": "えらーせいのどうさ",
    "desc": "未定義動作ではないが、誤ったプログラムの結果とされる動作。erroneous behavior (EB)。処理系によって診断や異常終了を実行することが許可されるが、処理が続行する場合もある"
  },
  "エラー性動作": { "redirect": "エラー性の動作", "yomi": "えらーせいどうさ" },
  "処理系定義の動作": {
    "link": "/implementation-compliance.md#dfn-implementation-defined-behavior",
    "yomi": "しょりけいていぎのどうさ",
    "desc": "処理系によって事前に定めた動作をする"
  },
  "処理系定義": { "redirect": "処理系定義の動作", "yomi": "しょりけいていぎ" },
  "実装定義の動作": { "redirect": "処理系定義の動作", "yomi": "じっそうていぎのどうさ" },
  "実装定義": { "redirect": "処理系定義の動作", "yomi": "じっそうていぎ" },
  "診断情報": {
    "link": "/implementation-compliance.md#dfn-diagnostic-message",
    "yomi": "しんだんじょうほう",
    "desc": "コンパイルエラーや警告。処理系がプログラム翻訳時に提供する情報の総称"
  },
  "診断メッセージ": { "redirect": "診断情報", "yomi": "しんだんめっせーじ" },
  "診断不要": {
    "link": "/implementation-compliance.md#dfn-no-diagnostic-required",
    "yomi": "しんだんふよう",
    "desc": "処理系は規則違反に対してエラーメッセージや警告を出さないかもしれない"
  },
  "カスタマイゼーションポイントオブジェクト": {
    "desc": "プログラム定義型に対するオーバーロードが許されている標準関数名について、中でいい感じにオーバーロード解決して呼び出してくれる関数オブジェクト"
  },
  "CPO": { "redirect": "カスタマイゼーションポイントオブジェクト" },
  "デフォルト初期化": {
    "yomi": "でふぉるとしょきか",
    "desc": "`T x;`構文での初期化。トリビアルにデフォルト構築可能な型の場合は初期化されず（オブジェクトのlifetimeは開始される）、そうではないクラス型はデフォルトコンストラクタで初期化する。配列型の場合は各要素が再帰的にデフォルト初期化される"
  },
  "デフォルト構築": {
    "yomi": "でふぉるとこうちく",
    "redirect": "デフォルト初期化"
  },
  "値初期化": {
    "yomi": "あたいしょきか",
    "desc": "`T x{};`構文での初期化。組み込み型の場合はゼロ相当の値で、クラス型の場合はデフォルトコンストラクタで初期化する。配列型の場合は各要素が再帰的に値初期化される"
  },
  "直接非リスト初期化": {
    "yomi": "ちょくせつひりすとしょきか",
    "desc": "direct-non-list-initialization。リスト初期化ではない直接初期化"
  },
  "値構築": {
    "yomi": "あたいこうちく",
    "redirect": "値初期化"
  },
  "プログラム定義型": {
    "yomi": "ぷろぐらむていぎがた",
    "desc": "標準ライブラリの型を除く、ユーザー（プログラマ）によって定義された型のこと"
  },
  "プログラム定義": {
    "yomi": "ぷろぐらむていぎ",
    "desc": "ユーザー（プログラマ）によって定義されること（標準ライブラリで定義されるものを除く）"
  },
  "ユーザー定義型": {
    "yomi": "ゆーざーていぎがた",
    "redirect": "プログラム定義型"
  },
  "ユーザー定義": {
    "yomi": "ゆーざーていぎ",
    "redirect": "プログラム定義"
  },
  "テンプレートパラメータ制約": {
    "yomi": "てんぷれーとぱらめーたせいやく",
    "desc": "関数等の意味論を構成する要素の1つ。Constraints。関数であればオーバーロード解決に参加するための条件、それ以外であれば受け付ける型の条件"
  },
  "適格要件": {
    "yomi": "てきかくようけん",
    "desc": "関数等の意味論を構成する要素の1つ。Mandates。満たさなければプログラムが不適格となる要件。この要件は、オーバーロード解決によって選択された関数内での`static_assert`の定数条件式や、関数に対するdelete宣言などで表現できる"
  },
  "事前条件": {
    "yomi": "じぜんじょうけん",
    "desc": "関数等の意味論を構成する要素の1つ。Preconditions。関数呼び出し時に満たされていると関数が想定する条件。満たさなければ未定義の動作。契約属性の`[[expects]]`に相当"
  },
  "事後条件": {
    "yomi": "じごじょうけん",
    "desc": "関数等の意味論を構成する要素の1つ。Postconditions。関数を実行後に満たされている条件。契約属性の`[[ensures]]`に相当"
  },
  "計算量": {
    "yomi": "けいさんりょう",
    "desc": "関数等の意味論を構成する要素の1つ。Complexity。関数が使うアルゴリズムの空間計算量・時間計算量"
  },
  "エラー条件": {
    "yomi": "えらーじょうけん",
    "desc": "関数等の意味論を構成する要素の1つ。Error conditions。関数が各エラーコードを返す条件"
  },
  "イテレータ範囲": {
    "yomi": "いてれーたはんい",
    "desc": "2つのイテレータで表現される半開区間を表す。C++20からイテレータと番兵で異なる型であっても指定可能になる"
  },
  "拡張浮動小数点数型": {
    "yomi": "かくちょうふどうしょうすうてんすうがた",
    "desc": "<stdfloat>で定義される内部表現の規定された浮動小数点数型",
    "link": "/reference/stdfloat.md"
  },
  "標準浮動小数点数型": {
    "yomi": "ひょうじゅんふどうしょうすうてんすうがた",
    "desc": "拡張浮動小数点数型の対義語としてfloat / double / long doubleを指す用語"
  },
  "ADL": {
    "desc": "実引数依存の名前探索 (Argument Dependent Lookup)。引数の型が所属する名前空間の関数を探索する言語機能"
  },
  "不完全型": {
    "yomi": "ふかんぜんがた",
    "desc": "型のサイズを決定できない、完全には定義されていない型。例えば先行宣言のみのクラス型、要素数不明の配列型、`void`など。クラス定義内部ではそのクラス自身は不完全型"
  },
  "完全型": {
    "yomi": "かんぜんがた",
    "desc": "型のサイズを決定できる型。不完全型ではない型"
  },
  "オーバーロード": {
    "desc": "同名の関数を異なる引数・テンプレート・制約などで複数定義すること。または同名の関数の集合"
  },
  "多重定義": {
    "yomi": "たじゅうていぎ",
    "redirect": "オーバーロード"
  },
  "オーバーロード解決": {
    "yomi": "おーばーろーどかいけつ",
    "desc": "関数呼び出し時に、同名の関数の中から実際に呼び出す関数を決定する処理。このときの候補になることを、オーバーロード解決に参加するという"
  },
  "多重定義解決": {
    "yomi": "たじゅうていぎかいけつ",
    "redirect": "オーバーロード解決"
  },
  "述語": {
    "yomi": "じゅつご",
    "desc": "boolを返す関数・関数オブジェクト。predicate"
  },
  "CV修飾": {
    "yomi": "しーぶいしゅうしょく",
    "desc": "型をconstおよび・もしくはvolatileで修飾すること"
  },
  "同期操作": {
    "yomi": "どうきそうさ",
    "desc": "マルチスレッド実行時にリソースの所有権に基づいて実行順序を制御する操作"
  },
  "戻り値": {
    "yomi": "もどりち",
    "desc": "関数呼び出し式の評価結果となるオブジェクト・値"
  },
  "例外": {
    "yomi": "れいがい",
    "desc": "問題が発生したときに、現在実行位置を過去に通過・記録した位置に戻し、文脈情報を添えて紐づけられた処理(例外ハンドラー)を呼び出す仕組み。またはその事態"
  },
  "ヌル終端": {
    "yomi": "ぬるしゅうたん",
    "desc": "null-terminated。文字列においてヌル文字 '\0' を用いてその終端を表すこと。ヌル文字自体は文字列に含まない。広義には線形データ構造においてヌルまたは値 0 を番兵としてその終わりを示すこと。"
  }
}

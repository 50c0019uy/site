# ほとんどの`volatile`を非推奨化
* cpp20[meta cpp]

## 概要

C++20より、`volatile`の本来の役割に照らして不正確、あるいは誤解を招く用法や無意味な用法について非推奨とされるようになる。

非推奨とされるだけで削除はされていないが、おそらくコンパイラはそれらの用法について警告を発するようになる。そのような用法はバグの原因となり危険であるため可能な限り使用を避けるべきである。

## `volatile`

`volatile`な変数（メモリ領域）への1度のアクセスは正確に1度だけ行われる必要があり、0回にも2回にもなってはならない。そして、`volatile`領域へのアクセスはその順序がコード上の順序と一致する必要がある。

`volatile`の効果（保証）は単純にはこれだけである。

ただし、`volatile`はそのようなメモリアクセスが分割されない事は保証していない。`volatile`メモリ領域の個々のバイトに対しては正確に1度のアクセスが保証されるが、`volatile`領域全体を見たときにアクセスが1度だけになるとは限らない。

そして、非`volatile`領域と`volatile`領域へのアクセスの間の相対的な順序が前後しない事まで保証していない。すなわち、`volatile`変数へのアクセスと通常の変数へのアクセスは順番が入れ替わりうる。

また、`volatile`はC++メモリモデルの一部ではなく、`volatile`領域へのアクセス順序とはC++メモリモデルにおける観測可能な順序を意味しない。プロセッサはC++コード上での順序で読み取った`volatile`領域へのアクセス命令を、アウトオブオーダーで発行・実行することができる。メモリモデルにおいて動作が保証されている同期機構を用いない場合、あるコアにおける命令の実行順は、他のコア（あるいはプロセッサの外部）からは異なった順序で実行されたかのように観測されうる。

`volatile`は主として、プログラムの実行環境のハードウェアなどのプログラム外部の環境との通信手段の一つとして利用され、スレッド間のやりとりなどプログラム内部での通信の手段としては適さない。そのような`vlatile`の正しい用法によるメモリの読み書きは、他のどの手段よりも移植性があり機能的にも優れており、言語機能として有用なものである。

## コア言語における非推奨化

### 複合代入演算子、インクリメント演算子

複合代入演算子とは`+= -= *= /=`など、ある操作とその結果の代入をまとめて行うような演算子のことである。

複合代入演算子およびインクリメント演算子は、「読み出し - 更新（処理） - 書き込み」という3つの操作を1文で行う。

```cpp
volatile int a = 0;
int b = 10;

a += b;
// これは以下と等価
// int tmp = a; 
// a = tmp + b;

++a;
// int tmp = a;
// a = tmp + 1;

a--;
// int tmp = a;
// a = tmp - 1;
```

複合代入演算子の左辺にある変数、およびインクリメント演算子のオペランドには2回のアクセス（読み込みと書き込み1回づつ）が発生するが、このアクセスは複合代入演算子やインクリメント演算子の見た目や一般的な理解とは必ずしも一致しない。

`volatile`変数においてはそのアクセス（読み書き）が重要であり、コード上での1回のアクセスは実行時にも1回だけアクセスされる必要がある。しかし、複合代入演算子およびインクリメント演算子のアクセス回数は多くのプログラマにとって曖昧であるか、誤解されている。

従って、算術型・ポインタ型の`volatile`変数に対する組み込みの複合代入演算子およびインクリメント演算子の使用はバグの元であるので、非推奨とされる。

この場合、これらの複合的な演算子を用いず、明示的に「読み出し - 更新 - 書き込み」を分けて書くことで`volatile`変数へのアクセスをコード上でも明確にする事が推奨される。

### 連鎖した代入演算子

代入演算子の一部の用法には、複合代入演算子・インクリメント演算子と同様の問題がある。

```cpp
volatile int a, b, c;

a = b = c = 10;
// このような順序でアクセスが発生する
// c = 10;
// b = c;
// a = b;
```

このような連なった代入演算子の用法においては、どの変数にどんな順番で何回アクセスされるのかが非常に分かりづらくなる。

`volatile`変数においてはそのアクセス（読み書き）が重要であり、コード上での1回のアクセスは実行時にも1回だけアクセスされ、かつその順番が前後してはならない。

従って、非クラス型の`volatile`変数に対するこのような組み込みの代入演算子の使用はバグの元であるので、非推奨とされる。

ただし、非推奨となるのは代入演算子の両端のオペランド以外に`volatile`変数が表れるケースである。

```cpp
volatile int v1, v2, v3;

v1 = v2 = v3 = 10; // NG（非推奨）

int n;
v1 = n = 10;      // OK

v1 = n = v3 = 10; // NG（非推奨）

v3 = 10;          // OK
v1 = v3;          // OK
v1 = n = v3;      // OK
```

### 関数引数と戻り値型
（執筆中）

### 構造化束縛宣言
（執筆中）

## ライブラリにおける非推奨化
（執筆中）

## この機能が必要になった背景・経緯
（執筆中）

## 検討されたほかの選択肢
（執筆中）

## 備考

非推奨化で触れられてはいないが、`volatile`変数を並行処理の共有変数として使用することは常に間違っている。

## 関連項目
（執筆中）

## 参照

- [P1152R0 Deprecating `volatile`](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p1152r0.html)
- [P1152R1 Deprecating `volatile`](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1152r1.html)
- [P1152R2 Deprecating `volatile`](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1152r2)
- [P1152R4 Deprecating `volatile`](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1152r4.html)
- [P1831R0 Deprecating `volatile`: library](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1831r0.html)
- [P1831R0 Deprecating `volatile`: library](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p1831r1.html)
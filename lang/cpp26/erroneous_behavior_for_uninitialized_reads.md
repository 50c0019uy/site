# 未初期化変数の読み取りを誤り起因動作とする [P2795R5]
* cpp26[meta cpp]

<!-- start lang caution -->

このページはC++26に採用される見込みの言語機能の変更を解説しています。

のちのC++規格でさらに変更される場合があるため[関連項目](#relative-page)を参照してください。

<!-- last lang caution -->

## 概要
C++23までは、未初期化変数 (デフォルト初期化された変数) の読み取りは未定義動作として扱われていた。C++26では、この未定義動作による安全上のリスクを低減するため、「誤り起因動作 (erroneous behavior; 通称 EB)」を新設してその多くに割り当てることとした。

```cpp example
// C++23
void f(int) {}

int main() {
  int x; // デフォルト初期化。xは不定値 (indeterminate value) をもつ
  f(x);  // 左辺値から右辺値への変換が未定義動作を引き起こす
}
```

未初期化の値は、コンパイラやターゲット環境によって定義された固定値である。コンパイラにはこの誤りを診断することが許可され、推奨されているが、誤りを無視して有効な読み取りとして扱うことも許可されている。このコードは誤りではあるが、未定義動作に関連する結果に遭遇するリスクはない。

誤り起因動作は未定義動作とはちがって、明確に定義された動作をするがコードとして正しくない、ということを規定するものであり、処理系に対して有用な診断を提供するものである。

C++26では、不定値で初期化されることを明確に指示する`[[indeterminate]]`属性も導入され、以下のような動作となる：

```cpp example
// C++26
void f(int) {}

int main() {
  int x;                   // xは誤り起因動作を引き起こす未初期化値をもつ
  int y [[indeterminate]]; // 意図して不定値に初期化されることを指示

  f(x); // 誤り起因動作 (未初期化値の読み取り)
  f(y); // 未定義動作 (不定値の読み取り)
}
```


## 仕様
- 式が評価された結果として不定値が生成された場合、未定義動作を引き起こす
- 式が評価された結果として未初期化値が生成された場合、誤り起因動作を引き起こす
    - 未初期価値が生成されることで誤り起因動作を引き起こす対象は以下：
        - 自動記憶域期間をもつオブジェクトのうち、`void`以外のスカラ型
            - 注意 : 動的記憶域期間をもつオブジェクトは対象外
        - ただし、`unsigned char`もしくは[`std::byte`](/reference/cstddef/byte.md)型に関しては、未初期化値をもつ変数を同じ型の変数に代入するだけでは誤り起因動作にならず、値の参照や型変換がされることで誤り起因動作を引き起こす
- 誤り起因動作が引き起こされた結果値は、後続の処理では誤り起因動作を引き起こす値とはみなされない

```cpp example
#include <cassert>

int g(bool b) {
  unsigned char c;
  unsigned char d = c; // 誤り起因動作ではない。dは誤り起因動作を引き起こす未初期化値をもつ

  assert(c == d);      // 常に真、誤り起因動作 (整数昇格)

  int e = d;           // 誤り起因動作 (型変換)
  return b ? d : 0;    // bがtrueの場合に誤り起因動作
}

int main() {
  int d1, d2;

  int e1 = d1;      // 誤り起因動作
  int e2 = d1;      // 誤り起因動作

  // 処理が続行した場合…
  assert(e1 == e2); // 常に真、誤り起因動作ではない。
                    // 誤り起因動作の結果で生成された値 (e1とe2) は、
                    // 誤り起因動作を引き起こす値とはみなされない
  assert(e1 == d1); // 常に真、誤り起因動作
  assert(e2 == d1); // 常に真、誤り起因動作

  // 誤り起因動作ではないが
  // d2は誤り起因動作を引き起こす未初期化値をもつ
  std::memcpy(&d2, &d1, sizeof(int));

  assert(e1 == d2); // 誤り起因動作
  assert(e2 == d2); // 誤り起因動作
}
```

### `[[indeterminate]]`属性
`[[indeterminate]]`属性は、自動変数が初期状態として意図して不定値をもつことを指示するものであり、自動変数の定義、もしくは関数のパラメータ宣言に適用できる。

関数のパラメータが`[[indeterminate]]`属性で宣言される場合、その関数の最初の宣言でそのように宣言されなければならない (注：関数宣言は複数行うことができるが、その最初の宣言で`[[indeterminate]]`属性をつけなければならない)。

`[[indeterminate]]`がつけられた変数から読み取りをした場合、未定義動作を引き起こす可能性がある。

```cpp example
struct T {
  T() {}
  int x;
};

int h(T t [[indeterminate]]) {
  f(t.x);   // この関数呼び出しは未定義動作を引き起こす
  return 0;
}

int main() {
  int _ = h(T());
}
```

### 今後、誤り起因動作に分類される可能性のある操作

現在、未定義動作に分類される以下の操作は、誤り起因動作に分類できる可能性がある。

| 操作 | 備考 |
|------|------|
| 符号付き整数のオーバーフロー | 演算結果としてオーバーフローした場合に誤った結果になる可能性がある。これは珍しいバグではない。これは安全上の大きな問題ではない |
| 算術型の変換結果としてその型の表現可能な範囲を超えた | 符号付き整数のオーバーフローと同じ |
| 誤ったビットシフト (負のシフト幅や、上限を超えたシフト幅) | 符号付き整数のオーバーフローと同じ |
| ゼロ割り | いくつかの固定値での誤った結果となる可能性がある。影響が不明確であるため、変更にはコストがかかる |
| 戻り値型が非`void`な関数から返った、もしくは`[[noreturn]]`属性をつけた関数から返った | [`std::terminate()`](/reference/exception/terminate.md)が呼ばれる可能性がある。変更には軽いコストがかかるが、その変更にどの程度の価値があるかは不明 |
| 抽象クラスのコンストラクタ・デストラクタからの純粋仮想関数の呼び出し | 特定の純粋仮想ハンドラが呼ばれる可能性がある。実装によってはすでに誤り起因動作のように扱われている可能性がある |
| 契約違反 | 契約に関する現在の策定作業では、契約違反時になにが起こるべきかという問題に直面している。誤り起因動作という概念は有用な回答を与えてくれる可能性がある |



## 参照
- [P2795R5 Erroneous behaviour for uninitialized reads](https://open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2795r5.html)

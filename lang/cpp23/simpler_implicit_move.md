# 暗黙的なムーブを簡略化
* cpp23[meta cpp]

## 概要

C++20の暗黙ムーブ仕様においては、暗黙ムーブ可能なもの（関数ローカルのオブジェクト/右辺値参照）が`return`文においてコピーされる場合に、可能ならば暗黙的にムーブして戻り値を構築するものだった。しかし、暗黙ムーブ可能なものを返しており`return`文でコピーが起こらない場合で、暗黙ムーブを行うことが適切な場合がまだ存在していた。

C++23ではその様なものを暗黙ムーブの対象に含めるために暗黙ムーブ仕様の調整が行われた。

```cpp
// 例示用のムーブ可能な型
struct Widget {
  Widget(Widget&&);
};

// Widgetの右辺値から構築可能な型
struct RRefTaker {
  RRefTaker(Widget&&);
};


auto example1(Widget w) -> RRefTaker {
  // ローカル変数の暗黙ムーブ
  return w;  // ok、C++11(CWG1579)から
}

auto example2(Widget&& w) -> RRefTaker {
  // ローカル右辺値参照の暗黙ムーブ
  return w;  // ok、C++20(P0527)から
}

auto example3(Widget&& w) -> Widget&& {
  // ローカル右辺値参照の暗黙ムーブ（戻り値型が参照型の場合）
  return w;  // C++20ではng、C++23からok
}

// 右辺値修飾変換演算子を持つ型
struct Jeff {
  operator int&() &&;
};

auto example4(Jeff x) -> int& {
  // ローカル変数の暗黙ムーブ（戻り値型が参照型の場合）
  return x;  // C++20ではng、C++23からok
}
```

上記例の`example3(), example4()`は、C++20までは戻り値型が参照型であるために`return`文でコピーは発生しないため、暗黙ムーブの対象になっていなかった。C++23では、これらの場合にも暗黙ムーブが試みられるようになる。

また同時に、C++11で導入されて以降少しづつその対象（暗黙ムーブが起こる場合および起こる場所）を拡大してきたことで複雑化していた暗黙ムーブ仕様が整理され、その仕様と実装がかなり単純化された。

## 仕様

**暗黙ムーブ可能なエンティティ**（*implicitly movable entity*）を次のどちらかとして指定する

- 自動記憶域期間の非`volatile`オブジェクト型変数
- 自動記憶域期間の非`volatile`オブジェクト型への右辺値参照

暗黙ムーブ可能なエンティティが次の場所で指名されている場合、その式は**ムーブする資格がある式**（*move-eligible*）となる

- `return/co_return`文のオペランド（以下の条件を全て満たすもの）
    - オペランドは変数名を指定する式（*id-expression*）であり（`()`で囲まれていても良い）
    - その変数名は、その文を囲む最も内側の関数（もしくはラムダ式）の本体内もしくは関数引数宣言内の、暗黙ムーブ可能なエンティティを指定している
- `throw`式のオペランド（以下の条件を全て満たすもの）
    - オペランドは変数名を指定する式であり（`()`で囲まれていても良い）
    - その変数名のスコープは、囲む最も内側のtryブロックのスコープよりも長くなく
    - その変数名は暗黙ムーブ可能なエンティティを指定している

そして、ムーブする資格がある式の値カテゴリは*xvalue*となる。

関数の戻り値は`return`文のオペランドからコピー初期化される。C++23において暗黙ムーブが可能な場合とはすなわち、`return`文のオペランドがムーブする資格がある式である場合のことで、その式（オペランド）は実際の値カテゴリがなんであれ*xvalue*として扱われる（つまり、`std::move()`されたのと等しくなる）ことで暗黙ムーブが適用される。

ムーブする資格がある式は必ず変数名を指定する式（*id-expression*）であるため、*prvalue*な`return`文オペランドに対して適用される[コピー省略](/lang/cpp17/guaranteed_copy_elision.md)と複合することは無い。NRVOとは複合しうるが、その場合は暗黙ムーブによって呼び出されるムーブコンストラクタの呼び出しがNRVOによって省略される。

### 副作用

この仕様の単純化はいくつか以前の動作を変更している。

まず、`return`文のオペランドがムーブする資格がある式となる場合その式の値カテゴリは*xvalue*として扱われることで、戻り値型推論の結果が変わる場合がある。

```cpp
auto f(int n) -> decltype(auto) {
  return (n);   // かっこに囲まれたid-expression、ムーブする資格がある式
}
// C++20 : 戻り値型はint&
// C++23 : 戻り値型はint&&

auto g(int n) -> auto&& {
  return n;     // id-expression、ムーブする資格がある式
}
// C++20 : 戻り値型はint&
// C++23 : 戻り値型はint&&
```

`decltype(auto)`による戻り値型推論では、`return`文のオペランドを`decltype`することで戻り値型を推論する。`decltype`は変数名に対して使用された時はその変数の宣言された型を取得するが、変数名がかっこに囲まれている場合はかっこに囲まれた*id-expression*として値カテゴリを含めたその式の型を取得する。このため、上記`f()`のように、`decltype(auto)`戻り値型の関数で`return`文のオペランドがかっこに囲まれた変数名であり、C++23でそのオペランドがムーブする資格がある式となる場合、その値カテゴリが変更される（*lvalue* -> *xvalue*）ことによって戻り値型推論結果が変化する。

`auto&&`による戻り値型推論は`decltype`と推論方法が異なるものの、やはり`return`文のオペランドの値カテゴリに応じて参照修飾が決定されるため、従来左辺値（*lvalue*）だったオペランドがC++23でムーブする資格がある式となる場合に、値カテゴリが*xvalue*となることによって推論結果が変化する。

この他の場合には結果は変化しない。

```cpp
auto f1(int n) -> decltype(auto) {
  return n;
}
// C++20/23共に戻り値型はint

auto f2(int n) -> auto {
  return n;
}
// C++20/23共に戻り値型はint

auto f3(int n) -> auto& {
  return n;
}
// C++20/23共に戻り値型はint&
// ただし、後述のようにC++23ではエラー

auto f4(int n) -> const auto& {
  return n;
}
// C++20/23共に戻り値型はconst int&
```

そして、同様に`return`文オペランドの値カテゴリが変化することによって、ローカル変数の参照を返す一部の関数が不適格になる様になる。

```cpp
auto f() -> int& {
  int n = 10;

  return n; // ng、nはムーブする資格のある式であり、その型と値カテゴリはint&&（戻り値型と一致しない）
}

auto g() -> std::reference_wrapper<int> {
  int n = 10;

  return n; // ng、nはムーブする資格のある式であり、その型と値カテゴリはint&&（reference_wrapperのコンストラクタで拒否される）
}
```
* reference_wrapper[link /reference/functional/reference_wrapper.md]

ただし、ローカル参照変数は暗黙ムーブ可能なエンティティではないため、ローカル参照を返そうとする場合従来通りエラーにはならない。

```cpp
auto f() -> int& {
  int n = 10;
  int& r = n;

  return r; // ok、rはムーブする資格のある式ではなく、その型と値カテゴリはint&
}
```

また、この変更とは逆に、ローカル変数の右辺値参照を返そうとする場合が適格になってしまう。

```cpp
auto f() -> int&& {
  int n = 10;

  return n; // C++20ではng
            // C++23ではok、nはムーブする資格のある式であり、その型と値カテゴリはint&&
}
```

### 副作用早見表

任意の型名を`T`（`T&&`は右辺値参照型）として、戻り値型推論とコンパイル可否の変化は次のようにまとめられる

|関数宣言と`return`文|C++20まで|C++23から|備考|
|---|:-:|:-:|---|
|`auto f(T x) -> decltype(x) { return x; }`       |`T` : 〇|`T` : 〇||
|`auto f(T x) -> decltype((x)) { return (x); }`   |`T&` : 〇|`T&` : **×**|ローカル参照を返していた|
|`auto f(T x) -> decltype(auto) { return x; }`    |`T` : 〇|`T` : 〇||
|`auto f(T x) -> decltype(auto) { return (x); }`  |`T&` : 〇|**`T&&` :** 〇|ローカル参照を返す|
|`auto f(T&& x) -> decltype(x) { return x; }`     |`T&&` : ×|`T&&` : **〇**||
|`auto f(T&& x) -> decltype((x)) { return (x); }` |`T&` : 〇|`T&` : **×**||
|`auto f(T&& x) -> decltype(auto) { return x; }`  |`T&&` : ×|`T&&` : **〇**|`x`がローカル変数の場合ローカル参照を返す|
|`auto f(T&& x) -> decltype(auto) { return (x); }`|`T&` : 〇|**`T&&` :** 〇|`x`がローカル変数の場合ローカル参照を返す|
|`auto f(T x) -> auto&& { return x; }`       |`T&` : 〇|**`T&&` :** 〇|ローカル参照を返す|
|`auto f(T x) -> auto&& { return (x); }`   |`T&` : 〇|**`T&&` :** 〇|ローカル参照を返す|
|`auto f(T&& x) -> auto&& { return x; }`       |`T&` : 〇|**`T&&` :** 〇|`x`がローカル変数の場合ローカル参照を返す|
|`auto f(T&& x) -> auto&& { return (x); }`   |`T&` : 〇|**`T&&` :** 〇|`x`がローカル変数の場合ローカル参照を返す|

右側2列の各項目内は、推論される戻り値型:コンパイル可否、のように記述しており、コンパイル可否は、〇が適格（コンパイルが通る）、×が不適格（コンパイルエラー）を表す。

## 例
(執筆中)

```cpp example
// (ここには、言語機能の使い方を解説するための、サンプルコードを記述します。)
// (インクルードとmain()関数を含む、実行可能なサンプルコードを記述してください。そのようなコードブロックにはexampleタグを付けます。)

#include <iostream>

int main()
{
  int variable = 0;
  std::cout << variable << std::endl;
}
```
* variable[color ff0000]

(コードブロック中の識別子に、文字色を付ける例です。)

### 出力
```
0
```

(ここには、サンプルコードの実行結果を記述します。何も出力がない場合は、項目を削除せず、空の出力にしてください。)  
(実行結果が処理系・実行環境によって異なる場合は、項目名を「出力例」に変更し、可能であればその理由も併記してください。)


## この機能が必要になった背景・経緯
(執筆中)

## 検討されたほかの選択肢
(執筆中)

## 関連項目
(執筆中)

## 参照

- [P2266R3 Simpler implicit move](https://wg21.link/p2266r3)
- [The Complete Guide to `return x;` - Arthur O'Dwyer - [CppNow 2021] - YouTube](https://www.youtube.com/watch?v=OGKAJD7bmr8)